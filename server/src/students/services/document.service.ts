// Academia Pro - Student Document Service
// Service for managing student documents, verification, and access control

import { Injectable, NotFoundException, BadRequestException, Logger } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository } from 'typeorm';
import { Student } from '../student.entity';
import { StudentDocument, DocumentType, DocumentStatus, VerificationMethod } from '../entities/student-document.entity';
import { CreateDocumentDto, UpdateDocumentDto } from '../dtos/create-document.dto';

@Injectable()
export class StudentDocumentService {
  private readonly logger = new Logger(StudentDocumentService.name);

  constructor(
    @InjectRepository(Student)
    private readonly studentRepository: Repository<Student>,
    @InjectRepository(StudentDocument)
    private readonly documentRepository: Repository<StudentDocument>,
  ) {}

  /**
   * Upload a new document for a student
   */
  async uploadDocument(
    studentId: string,
    createDto: CreateDocumentDto,
    uploadedBy: string,
    uploadedByName: string,
    uploadIpAddress?: string,
  ): Promise<StudentDocument> {
    // Verify student exists
    const student = await this.studentRepository.findOne({
      where: { id: studentId },
      select: ['id', 'firstName', 'lastName'],
    });

    if (!student) {
      throw new NotFoundException(`Student with ID ${studentId} not found`);
    }

    // Create document record
    const document = this.documentRepository.create({
      studentId,
      documentType: createDto.documentType,
      documentName: createDto.documentName,
      documentDescription: createDto.documentDescription,
      status: DocumentStatus.SUBMITTED,
      fileName: createDto.originalFileName, // This would be generated by file upload service
      originalFileName: createDto.originalFileName,
      fileUrl: createDto.fileUrl,
      fileSizeBytes: createDto.fileSizeBytes,
      mimeType: createDto.mimeType,
      uploadedBy,
      uploadedByName,
      uploadIpAddress,
      verificationRequired: createDto.verificationRequired !== undefined ? createDto.verificationRequired : true,
      verificationStatus: 'pending',
      issueDate: createDto.issueDate ? new Date(createDto.issueDate) : undefined,
      expiryDate: createDto.expiryDate ? new Date(createDto.expiryDate) : undefined,
      isExpired: false,
      renewalRequired: false,
      isConfidential: createDto.isConfidential || false,
      accessRestricted: false,
      allowedRoles: createDto.allowedRoles || ['admin', 'teacher', 'parent'],
      documentNumber: createDto.documentNumber,
      issuingAuthority: createDto.issuingAuthority,
      // issuingCountry and issuingState are optional and can be set later
      metadata: {
        category: 'student_document',
        priority: 'normal',
        tags: [createDto.documentType],
      },
      versionNumber: 1,
      isLatestVersion: true,
      downloadCount: 0,
      viewCount: 0,
    });

    const savedDocument = await this.documentRepository.save(document);

    this.logger.log(`Document uploaded ${savedDocument.id} for student ${studentId}`);
    return savedDocument;
  }

  /**
   * Get all documents for a student
   */
  async getStudentDocuments(
    studentId: string,
    options?: {
      status?: string;
      type?: string;
      verificationStatus?: string;
      limit?: number;
      offset?: number;
    },
  ): Promise<StudentDocument[]> {
    const queryBuilder = this.documentRepository
      .createQueryBuilder('document')
      .where('document.studentId = :studentId', { studentId })
      .orderBy('document.uploadDate', 'DESC');

    if (options?.status) {
      queryBuilder.andWhere('document.status = :status', { status: options.status });
    }

    if (options?.type) {
      queryBuilder.andWhere('document.documentType = :type', { type: options.type });
    }

    if (options?.verificationStatus) {
      queryBuilder.andWhere('document.verificationStatus = :verificationStatus', {
        verificationStatus: options.verificationStatus,
      });
    }

    if (options?.limit) {
      queryBuilder.limit(options.limit);
    }

    if (options?.offset) {
      queryBuilder.offset(options.offset);
    }

    return queryBuilder.getMany();
  }

  /**
   * Get a specific document
   */
  async getDocument(documentId: string): Promise<StudentDocument> {
    const document = await this.documentRepository.findOne({
      where: { id: documentId },
      relations: ['student'],
    });

    if (!document) {
      throw new NotFoundException(`Document with ID ${documentId} not found`);
    }

    return document;
  }

  /**
   * Update a document
   */
  async updateDocument(
    documentId: string,
    updateDto: UpdateDocumentDto,
  ): Promise<StudentDocument> {
    const document = await this.documentRepository.findOne({
      where: { id: documentId },
    });

    if (!document) {
      throw new NotFoundException(`Document with ID ${documentId} not found`);
    }

    // Prepare update data
    const updateData: Partial<StudentDocument> = {};

    if (updateDto.documentName) updateData.documentName = updateDto.documentName;
    if (updateDto.documentDescription !== undefined) updateData.documentDescription = updateDto.documentDescription;
    if (updateDto.status) updateData.status = updateDto.status as any;
    if (updateDto.documentNumber !== undefined) updateData.documentNumber = updateDto.documentNumber;
    if (updateDto.issuingAuthority !== undefined) updateData.issuingAuthority = updateDto.issuingAuthority;
    if (updateDto.issueDate) updateData.issueDate = new Date(updateDto.issueDate);
    if (updateDto.expiryDate) updateData.expiryDate = new Date(updateDto.expiryDate);
    if (updateDto.isConfidential !== undefined) updateData.isConfidential = updateDto.isConfidential;
    if (updateDto.allowedRoles) updateData.allowedRoles = updateDto.allowedRoles;

    await this.documentRepository.update(documentId, updateData);

    const updatedDocument = await this.getDocument(documentId);
    this.logger.log(`Updated document ${documentId}`);
    return updatedDocument;
  }

  /**
   * Delete a document
   */
  async deleteDocument(documentId: string): Promise<void> {
    const document = await this.documentRepository.findOne({
      where: { id: documentId },
    });

    if (!document) {
      throw new NotFoundException(`Document with ID ${documentId} not found`);
    }

    await this.documentRepository.remove(document);
    this.logger.log(`Deleted document ${documentId}`);
  }

  /**
   * Get documents by type
   */
  async getDocumentsByType(
    studentId: string,
    documentType: string,
  ): Promise<StudentDocument[]> {
    return this.documentRepository.find({
      where: {
        studentId,
        documentType: documentType as any,
      },
      order: {
        uploadDate: 'DESC',
      },
    });
  }

  /**
   * Get documents by status
   */
  async getDocumentsByStatus(
    studentId: string,
    status: string,
  ): Promise<StudentDocument[]> {
    return this.documentRepository.find({
      where: {
        studentId,
        status: status as any,
      },
      order: {
        uploadDate: 'DESC',
      },
    });
  }

  /**
   * Get verified documents
   */
  async getVerifiedDocuments(studentId: string): Promise<StudentDocument[]> {
    return this.documentRepository.find({
      where: {
        studentId,
        verificationStatus: 'verified',
      },
      order: {
        uploadDate: 'DESC',
      },
    });
  }

  /**
   * Get documents requiring verification
   */
  async getDocumentsRequiringVerification(studentId: string): Promise<StudentDocument[]> {
    return this.documentRepository.find({
      where: {
        studentId,
        verificationRequired: true,
        verificationStatus: 'pending',
      },
      order: {
        uploadDate: 'ASC',
      },
    });
  }

  /**
   * Get expired documents
   */
  async getExpiredDocuments(studentId: string): Promise<StudentDocument[]> {
    return this.documentRepository.find({
      where: {
        studentId,
        isExpired: true,
      },
      order: {
        expiryDate: 'ASC',
      },
    });
  }

  /**
   * Get documents requiring renewal
   */
  async getDocumentsRequiringRenewal(studentId: string): Promise<StudentDocument[]> {
    return this.documentRepository.find({
      where: {
        studentId,
        renewalRequired: true,
      },
      order: {
        renewalReminderDate: 'ASC',
      },
    });
  }

  /**
   * Search documents
   */
  async searchDocuments(
    studentId: string,
    searchTerm: string,
  ): Promise<StudentDocument[]> {
    const queryBuilder = this.documentRepository
      .createQueryBuilder('document')
      .where('document.studentId = :studentId', { studentId })
      .andWhere(
        '(document.documentName ILIKE :searchTerm OR document.documentDescription ILIKE :searchTerm OR document.documentNumber ILIKE :searchTerm)',
        { searchTerm: `%${searchTerm}%` },
      )
      .orderBy('document.uploadDate', 'DESC');

    return queryBuilder.getMany();
  }

  /**
   * Verify a document
   */
  async verifyDocument(
    documentId: string,
    verifiedBy: string,
    verifiedByName: string,
    verificationMethod: VerificationMethod,
    verificationNotes?: string,
  ): Promise<StudentDocument> {
    const document = await this.documentRepository.findOne({
      where: { id: documentId },
    });

    if (!document) {
      throw new NotFoundException(`Document with ID ${documentId} not found`);
    }

    await this.documentRepository.update(documentId, {
      verificationStatus: 'verified',
      verificationMethod,
      verifiedBy,
      verifiedByName,
      verificationDate: new Date(),
      verificationNotes,
      status: DocumentStatus.VERIFIED,
    });

    const updatedDocument = await this.getDocument(documentId);
    this.logger.log(`Verified document ${documentId}`);
    return updatedDocument;
  }

  /**
   * Reject a document
   */
  async rejectDocument(
    documentId: string,
    rejectionReason: string,
    rejectedBy: string,
    rejectedByName: string,
  ): Promise<StudentDocument> {
    const document = await this.documentRepository.findOne({
      where: { id: documentId },
    });

    if (!document) {
      throw new NotFoundException(`Document with ID ${documentId} not found`);
    }

    await this.documentRepository.update(documentId, {
      verificationStatus: 'rejected',
      rejectionReason,
      verifiedBy: rejectedBy,
      verifiedByName: rejectedByName,
      verificationDate: new Date(),
      status: DocumentStatus.REJECTED,
    });

    const updatedDocument = await this.getDocument(documentId);
    this.logger.log(`Rejected document ${documentId}`);
    return updatedDocument;
  }

  /**
   * Record document access (view/download)
   */
  async recordDocumentAccess(
    documentId: string,
    accessType: 'view' | 'download',
    accessedBy: string,
  ): Promise<void> {
    const document = await this.documentRepository.findOne({
      where: { id: documentId },
    });

    if (!document) {
      throw new NotFoundException(`Document with ID ${documentId} not found`);
    }

    const updateData: Partial<StudentDocument> = {};

    if (accessType === 'view') {
      updateData.viewCount = (document.viewCount || 0) + 1;
      updateData.lastViewedAt = new Date();
      updateData.lastViewedBy = accessedBy;
    } else if (accessType === 'download') {
      updateData.downloadCount = (document.downloadCount || 0) + 1;
      updateData.lastDownloadedAt = new Date();
      updateData.lastDownloadedBy = accessedBy;
    }

    await this.documentRepository.update(documentId, updateData);
  }

  /**
   * Check if document is accessible by user role
   */
  async isDocumentAccessible(documentId: string, userRole: string): Promise<boolean> {
    const document = await this.documentRepository.findOne({
      where: { id: documentId },
      select: ['id', 'isConfidential', 'accessRestricted', 'allowedRoles', 'accessExpiresAt'],
    });

    if (!document) {
      return false;
    }

    // Check if access is expired
    if (document.accessExpiresAt && new Date() > document.accessExpiresAt) {
      return false;
    }

    // Check role-based access
    if (document.accessRestricted && !document.allowedRoles.includes(userRole)) {
      return false;
    }

    return true;
  }

  /**
   * Get document statistics for a student
   */
  async getDocumentStatistics(studentId: string): Promise<{
    totalDocuments: number;
    verifiedDocuments: number;
    pendingVerification: number;
    rejectedDocuments: number;
    expiredDocuments: number;
    documentsByType: Record<string, number>;
    documentsByStatus: Record<string, number>;
    recentUploads: number;
  }> {
    const [totalDocuments, verifiedDocuments, pendingVerification, rejectedDocuments, expiredDocuments] = await Promise.all([
      this.documentRepository.count({ where: { studentId } }),
      this.documentRepository.count({
        where: { studentId, verificationStatus: 'verified' },
      }),
      this.documentRepository.count({
        where: { studentId, verificationStatus: 'pending' },
      }),
      this.documentRepository.count({
        where: { studentId, verificationStatus: 'rejected' },
      }),
      this.documentRepository.count({
        where: { studentId, isExpired: true },
      }),
    ]);

    // Get documents by type
    const documentsByType = await this.documentRepository
      .createQueryBuilder('document')
      .select('document.documentType', 'type')
      .addSelect('COUNT(*)', 'count')
      .where('document.studentId = :studentId', { studentId })
      .groupBy('document.documentType')
      .getRawMany();

    const typeStats = {};
    documentsByType.forEach(item => {
      typeStats[item.type] = parseInt(item.count);
    });

    // Get documents by status
    const documentsByStatus = await this.documentRepository
      .createQueryBuilder('document')
      .select('document.status', 'status')
      .addSelect('COUNT(*)', 'count')
      .where('document.studentId = :studentId', { studentId })
      .groupBy('document.status')
      .getRawMany();

    const statusStats = {};
    documentsByStatus.forEach(item => {
      statusStats[item.status] = parseInt(item.count);
    });

    // Get recent uploads (last 30 days)
    const thirtyDaysAgo = new Date();
    thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);

    const recentUploads = await this.documentRepository.count({
      where: {
        studentId,
        uploadDate: thirtyDaysAgo as any,
      },
    });

    return {
      totalDocuments,
      verifiedDocuments,
      pendingVerification,
      rejectedDocuments,
      expiredDocuments,
      documentsByType: typeStats,
      documentsByStatus: statusStats,
      recentUploads,
    };
  }

  /**
   * Check for expired documents and mark them
   */
  async checkExpiredDocuments(studentId: string): Promise<StudentDocument[]> {
    const currentDate = new Date();

    // Find documents that have expired but aren't marked as expired
    const expiredDocuments = await this.documentRepository
      .createQueryBuilder('document')
      .where('document.studentId = :studentId', { studentId })
      .andWhere('document.expiryDate IS NOT NULL')
      .andWhere('document.expiryDate < :currentDate', { currentDate })
      .andWhere('document.isExpired = false')
      .getMany();

    // Mark them as expired
    if (expiredDocuments.length > 0) {
      await this.documentRepository.update(
        { id: { $in: expiredDocuments.map(doc => doc.id) } } as any,
        { isExpired: true, renewalRequired: true },
      );
    }

    return expiredDocuments;
  }
}